from rdkit import Chem
import requests
import pandas as pd
import numpy as np


#récupération des chaînes de caractères (smiles format str) dans la liste "data"
r = requests.get('https://raw.githubusercontent.com/aspuru-guzik-group/selfies/master/examples/vae_example/datasets/dataJ_250k_rndm_zinc_drugs_clean.txt')
data = r.text.split('\n')[:-1]

#conversion des smiles format str en objets rdkit.Mol dans la liste "mols"
mols = [Chem.MolFromSmiles(S) for S in data]
#mols = liste contenant des

#initialisation des éléments que l'on va rechercher
elem = ['C', 'N', 'O'#, 'H'
        ]

#initialisation de la liste "filtre" dans laquelle on va ajouter les molécules qui répondent à la condition
filtre = []

#on ajoute des smiles format str à la liste "filtre"
#en bouclant sur les listes data et mols
#càd on ajoute les smiles correspondant à chaque molécule qui contient tous les éléments de la liste elem
for smi, mol in zip(data, mols):
    if all([atom.GetSymbol() in elem for atom in mol.GetAtoms()]):
        filtre.append(smi)


#on insert les smiles filtrés dans un dataframe
df = pd.DataFrame({'smiles': filtre[:15]})

#print(df.head())


'''
#visualiser les molécules
PandasTools.AddMoleculeColumnToFrame(df, smilesCol="smiles", molCol="Mol2D")

img = Draw.MolsToGridImage(list(df.Mol2D[0:10]), legends=list(df.smiles[0:10]), molsPerRow=5)
img.show()
'''

def assess_two_letter_elements(df):
    """
    Find the two letter elements in dataframe.

    Parameters
    ----------
    df : pandas.DataFrame
        Dataframe which requires preprocessing.

    Returns
    -------
    two_letter_elements : list
        List with found two letter elements
    """

    # Search for unique characters in SMILES strings
    unique_chars = set(df.smiles.apply(list).sum())
    # Get upper and lower case letters only
    upper_chars = []
    lower_chars = []
    for entry in unique_chars:
        if entry.isalpha():
            if entry.isupper():
                upper_chars.append(entry)
            elif entry.islower():
                lower_chars.append(entry)
    print(f"Upper letter characters {sorted(upper_chars)}")
    print(f"Lower letter characters {sorted(lower_chars)}")

    # List of all possible periodic elements
    #(éléments contenus dans le dataset uniquement)
    periodic_elements = ['C', 'O', 'N', 'F', 'S', 'Cl', 'Br', 'I', 'P']

    # The two_char_elements list contains all two letter elements
    # which can be generated by all possible combination of upper x lower characters
    # and are valid periodic elements.
    two_char_elements = []
    for upper in upper_chars:
        for lower in lower_chars:
            ch = upper + lower
            if ch in periodic_elements:
                two_char_elements.append(ch)

    # This list is then reduced to the subset of two-letter elements
    # that actually appear in the SMILES strings, specific to our data set.
    two_char_elements_smiles = set()
    for char in two_char_elements:
        if df.smiles.str.contains(char).any():
            two_char_elements_smiles.add(char)

    return two_char_elements_smiles

elements_found = assess_two_letter_elements(df)
print(f"\nTwo letter elements found in the data set: {sorted(elements_found)}")


replace_dict = {"@@": "Z"}


def preprocessing_data(df, replacement):
    """
    Preprocess the SMILES structures in a data set.

    Parameters
    ----------
    df : pandas.DataFrame
      Dataframe which requires preprocessing.
    replacement : dict
      Dictionary with mapping for replacement.

    Returns
    -------
    df : pandas.DataFrame
        Dataframe with new processed canonical SMILES column.
    unique_char : list
        List with unique characters present in SMILES.
    """

    # Create a new column having processed canonical SMILES
    df["processed_smiles"] = df["smiles"].copy()

    # Replace the two letter elements found with one character
    for pattern, repl in replacement.items():
        df["processed_smiles"] = df["processed_smiles"].str.replace(
            pattern, repl
        )

    unique_char = set(df.processed_smiles.apply(list).sum())
    return df, unique_char

df, unique_char = preprocessing_data(df, replace_dict)

# Print unique characters
print(f"All unique characters found in the preprocessed data set:\n{sorted(unique_char)}")


# Index of the longest SMILES string
longest_smiles = max(df["smiles"], key=len)
longest_smiles_index = df.smiles[df.smiles == longest_smiles].index.tolist()
#print(f"Longest SMILES: {longest_smiles}")
print(f"Contains {len(longest_smiles)} characters, index in dataframe: {longest_smiles_index[0]}.")
smiles_maxlen = len(longest_smiles)


'''
# Index of the shortest SMILES string
shortest_smiles = min(df["smiles"], key=len)
shortest_smiles_index = df.smiles[df.smiles == shortest_smiles].index.tolist()
#print(f"Shortest SMILES: {shortest_smiles}")
print(f"Contains {len(shortest_smiles)} characters, index in dataframe: {shortest_smiles_index[0]}.")
'''

# Function defined to create one-hot encoded matrix
def smiles_encoder(smiles, max_len, unique_char):
    """
    Function defined using all unique characters in our
    processed canonical SMILES structures created
    with the preprocessing_data function.

    Parameters
    ----------
    smiles : str
         SMILES of a molecule in string format.
    unique_char : list
         List of unique characters in the string data set.
    max_len : int
         Maximum length of the SMILES string.

    Returns
    -------
    smiles_matrix : numpy.ndarray
         One-hot encoded matrix of fixed shape
         (unique char in smiles, max SMILES length).
    """
    # create dictionary of the unique char data set
    smi2index = {char: index for index, char in enumerate(unique_char)}
    # one-hot encoding
    # zero padding to max_len
    smiles_matrix = np.zeros((len(unique_char), max_len))
    for index, char in enumerate(smiles):
        smiles_matrix[smi2index[char], index] = 1
    return smiles_matrix

# Apply the function to the processed canonical SMILES strings
df["unique_char_ohe_matrix"] = df["processed_smiles"].apply(
    smiles_encoder, max_len=smiles_maxlen, unique_char=unique_char
)
print(df.head())
